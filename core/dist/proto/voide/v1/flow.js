// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: voide/v1/flow.proto
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
export const protobufPackage = "voide.v1";
function createBaseUserText() {
    return { text: "" };
}
export const UserText = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.text !== "") {
            writer.uint32(10).string(message.text);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserText();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.text = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.text !== "") {
            obj.text = message.text;
        }
        return obj;
    },
    create(base) {
        return UserText.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserText();
        message.text = object.text ?? "";
        return message;
    },
};
function createBasePromptText() {
    return { text: "" };
}
export const PromptText = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.text !== "") {
            writer.uint32(10).string(message.text);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePromptText();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.text = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.text !== "") {
            obj.text = message.text;
        }
        return obj;
    },
    create(base) {
        return PromptText.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePromptText();
        message.text = object.text ?? "";
        return message;
    },
};
function createBaseLLMText() {
    return { text: "" };
}
export const LLMText = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.text !== "") {
            writer.uint32(10).string(message.text);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLLMText();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.text = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.text !== "") {
            obj.text = message.text;
        }
        return obj;
    },
    create(base) {
        return LLMText.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLLMText();
        message.text = object.text ?? "";
        return message;
    },
};
function createBaseAnyBlob() {
    return { data: new Uint8Array(0) };
}
export const AnyBlob = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.data.length !== 0) {
            writer.uint32(10).bytes(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAnyBlob();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.data = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
    },
    toJSON(message) {
        const obj = {};
        if (message.data.length !== 0) {
            obj.data = base64FromBytes(message.data);
        }
        return obj;
    },
    create(base) {
        return AnyBlob.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAnyBlob();
        message.data = object.data ?? new Uint8Array(0);
        return message;
    },
};
function createBasePort() {
    return { port: "", types: [] };
}
export const Port = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.port !== "") {
            writer.uint32(10).string(message.port);
        }
        for (const v of message.types) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePort();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.types.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            port: isSet(object.port) ? globalThis.String(object.port) : "",
            types: globalThis.Array.isArray(object?.types) ? object.types.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.port !== "") {
            obj.port = message.port;
        }
        if (message.types?.length) {
            obj.types = message.types;
        }
        return obj;
    },
    create(base) {
        return Port.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePort();
        message.port = object.port ?? "";
        message.types = object.types?.map((e) => e) || [];
        return message;
    },
};
function createBaseNodePort() {
    return { node: "", port: "" };
}
export const NodePort = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.node !== "") {
            writer.uint32(10).string(message.node);
        }
        if (message.port !== "") {
            writer.uint32(18).string(message.port);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNodePort();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.node = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.port = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            node: isSet(object.node) ? globalThis.String(object.node) : "",
            port: isSet(object.port) ? globalThis.String(object.port) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.node !== "") {
            obj.node = message.node;
        }
        if (message.port !== "") {
            obj.port = message.port;
        }
        return obj;
    },
    create(base) {
        return NodePort.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseNodePort();
        message.node = object.node ?? "";
        message.port = object.port ?? "";
        return message;
    },
};
function createBaseNode() {
    return { id: "", type: "", name: "", paramsJson: "", in: [], out: [] };
}
export const Node = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.type !== "") {
            writer.uint32(18).string(message.type);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.paramsJson !== "") {
            writer.uint32(34).string(message.paramsJson);
        }
        for (const v of message.in) {
            Port.encode(v, writer.uint32(42).fork()).ldelim();
        }
        for (const v of message.out) {
            Port.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.paramsJson = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.in.push(Port.decode(reader, reader.uint32()));
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.out.push(Port.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            paramsJson: isSet(object.paramsJson) ? globalThis.String(object.paramsJson) : "",
            in: globalThis.Array.isArray(object?.in) ? object.in.map((e) => Port.fromJSON(e)) : [],
            out: globalThis.Array.isArray(object?.out) ? object.out.map((e) => Port.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.paramsJson !== "") {
            obj.paramsJson = message.paramsJson;
        }
        if (message.in?.length) {
            obj.in = message.in.map((e) => Port.toJSON(e));
        }
        if (message.out?.length) {
            obj.out = message.out.map((e) => Port.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Node.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseNode();
        message.id = object.id ?? "";
        message.type = object.type ?? "";
        message.name = object.name ?? "";
        message.paramsJson = object.paramsJson ?? "";
        message.in = object.in?.map((e) => Port.fromPartial(e)) || [];
        message.out = object.out?.map((e) => Port.fromPartial(e)) || [];
        return message;
    },
};
function createBaseEdge() {
    return { id: "", from: undefined, to: undefined, label: "", type: "" };
}
export const Edge = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.from !== undefined) {
            NodePort.encode(message.from, writer.uint32(18).fork()).ldelim();
        }
        if (message.to !== undefined) {
            NodePort.encode(message.to, writer.uint32(26).fork()).ldelim();
        }
        if (message.label !== "") {
            writer.uint32(34).string(message.label);
        }
        if (message.type !== "") {
            writer.uint32(42).string(message.type);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEdge();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.from = NodePort.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.to = NodePort.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.label = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            from: isSet(object.from) ? NodePort.fromJSON(object.from) : undefined,
            to: isSet(object.to) ? NodePort.fromJSON(object.to) : undefined,
            label: isSet(object.label) ? globalThis.String(object.label) : "",
            type: isSet(object.type) ? globalThis.String(object.type) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.from !== undefined) {
            obj.from = NodePort.toJSON(message.from);
        }
        if (message.to !== undefined) {
            obj.to = NodePort.toJSON(message.to);
        }
        if (message.label !== "") {
            obj.label = message.label;
        }
        if (message.type !== "") {
            obj.type = message.type;
        }
        return obj;
    },
    create(base) {
        return Edge.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEdge();
        message.id = object.id ?? "";
        message.from = (object.from !== undefined && object.from !== null) ? NodePort.fromPartial(object.from) : undefined;
        message.to = (object.to !== undefined && object.to !== null) ? NodePort.fromPartial(object.to) : undefined;
        message.label = object.label ?? "";
        message.type = object.type ?? "";
        return message;
    },
};
function createBaseFlow() {
    return { id: "", version: "", nodes: [], edges: [] };
}
export const Flow = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        for (const v of message.nodes) {
            Node.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.edges) {
            Edge.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlow();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.nodes.push(Node.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.edges.push(Edge.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            version: isSet(object.version) ? globalThis.String(object.version) : "",
            nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e) => Node.fromJSON(e)) : [],
            edges: globalThis.Array.isArray(object?.edges) ? object.edges.map((e) => Edge.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.version !== "") {
            obj.version = message.version;
        }
        if (message.nodes?.length) {
            obj.nodes = message.nodes.map((e) => Node.toJSON(e));
        }
        if (message.edges?.length) {
            obj.edges = message.edges.map((e) => Edge.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Flow.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlow();
        message.id = object.id ?? "";
        message.version = object.version ?? "";
        message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
        message.edges = object.edges?.map((e) => Edge.fromPartial(e)) || [];
        return message;
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}

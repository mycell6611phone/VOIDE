// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: voide/v1/flow.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "voide.v1";

export interface UserText {
  text: string;
}

export interface PromptText {
  text: string;
}

export interface LLMText {
  text: string;
}

export interface AnyBlob {
  data: Uint8Array;
}

export interface NodeConfig {
  id: string;
  type: string;
}

export interface Edge {
  from: string;
  to: string;
  type: string;
}

export interface Flow {
  nodes: NodeConfig[];
  edges: Edge[];
}

export interface InputCfg {
  id: string;
}

export interface PromptCfg {
  id: string;
}

export interface LLMCfg {
  model: string;
}

export interface BranchCfg {
  condition: string;
}

export interface LogCfg {
  name: string;
}

export interface OutputCfg {
  name: string;
}

export interface ExecuteRequest {
  flow: Flow | undefined;
}

export interface PortValue {
  port: string;
  value: Uint8Array;
  type: string;
}

export interface NodeEvent {
  nodeId: string;
  event: string;
  value: PortValue | undefined;
}

export interface ExecuteResponse {
  events: NodeEvent[];
}

function createBaseUserText(): UserText {
  return { text: "" };
}

export const UserText = {
  encode(message: UserText, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserText {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserText {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: UserText): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserText>, I>>(base?: I): UserText {
    return UserText.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserText>, I>>(object: I): UserText {
    const message = createBaseUserText();
    message.text = object.text ?? "";
    return message;
  },
};

function createBasePromptText(): PromptText {
  return { text: "" };
}

export const PromptText = {
  encode(message: PromptText, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PromptText {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptText {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: PromptText): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PromptText>, I>>(base?: I): PromptText {
    return PromptText.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PromptText>, I>>(object: I): PromptText {
    const message = createBasePromptText();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseLLMText(): LLMText {
  return { text: "" };
}

export const LLMText = {
  encode(message: LLMText, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMText {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMText {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: LLMText): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMText>, I>>(base?: I): LLMText {
    return LLMText.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMText>, I>>(object: I): LLMText {
    const message = createBaseLLMText();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseAnyBlob(): AnyBlob {
  return { data: new Uint8Array(0) };
}

export const AnyBlob = {
  encode(message: AnyBlob, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnyBlob {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnyBlob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnyBlob {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
  },

  toJSON(message: AnyBlob): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnyBlob>, I>>(base?: I): AnyBlob {
    return AnyBlob.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnyBlob>, I>>(object: I): AnyBlob {
    const message = createBaseAnyBlob();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNodeConfig(): NodeConfig {
  return { id: "", type: "" };
}

export const NodeConfig = {
  encode(message: NodeConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfig {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: NodeConfig): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeConfig>, I>>(base?: I): NodeConfig {
    return NodeConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeConfig>, I>>(object: I): NodeConfig {
    const message = createBaseNodeConfig();
    message.id = object.id ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseEdge(): Edge {
  return { from: "", to: "", type: "" };
}

export const Edge = {
  encode(message: Edge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Edge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Edge {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: Edge): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Edge>, I>>(base?: I): Edge {
    return Edge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Edge>, I>>(object: I): Edge {
    const message = createBaseEdge();
    message.from = object.from ?? "";
    message.to = object.to ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseFlow(): Flow {
  return { nodes: [], edges: [] };
}

export const Flow = {
  encode(message: Flow, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.nodes) {
      NodeConfig.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.edges) {
      Edge.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Flow {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodes.push(NodeConfig.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.edges.push(Edge.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Flow {
    return {
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => NodeConfig.fromJSON(e)) : [],
      edges: globalThis.Array.isArray(object?.edges) ? object.edges.map((e: any) => Edge.fromJSON(e)) : [],
    };
  },

  toJSON(message: Flow): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => NodeConfig.toJSON(e));
    }
    if (message.edges?.length) {
      obj.edges = message.edges.map((e) => Edge.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Flow>, I>>(base?: I): Flow {
    return Flow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Flow>, I>>(object: I): Flow {
    const message = createBaseFlow();
    message.nodes = object.nodes?.map((e) => NodeConfig.fromPartial(e)) || [];
    message.edges = object.edges?.map((e) => Edge.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInputCfg(): InputCfg {
  return { id: "" };
}

export const InputCfg = {
  encode(message: InputCfg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InputCfg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputCfg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputCfg {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: InputCfg): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputCfg>, I>>(base?: I): InputCfg {
    return InputCfg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputCfg>, I>>(object: I): InputCfg {
    const message = createBaseInputCfg();
    message.id = object.id ?? "";
    return message;
  },
};

function createBasePromptCfg(): PromptCfg {
  return { id: "" };
}

export const PromptCfg = {
  encode(message: PromptCfg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PromptCfg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptCfg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptCfg {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: PromptCfg): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PromptCfg>, I>>(base?: I): PromptCfg {
    return PromptCfg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PromptCfg>, I>>(object: I): PromptCfg {
    const message = createBasePromptCfg();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseLLMCfg(): LLMCfg {
  return { model: "" };
}

export const LLMCfg = {
  encode(message: LLMCfg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMCfg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMCfg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMCfg {
    return { model: isSet(object.model) ? globalThis.String(object.model) : "" };
  },

  toJSON(message: LLMCfg): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMCfg>, I>>(base?: I): LLMCfg {
    return LLMCfg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMCfg>, I>>(object: I): LLMCfg {
    const message = createBaseLLMCfg();
    message.model = object.model ?? "";
    return message;
  },
};

function createBaseBranchCfg(): BranchCfg {
  return { condition: "" };
}

export const BranchCfg = {
  encode(message: BranchCfg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.condition !== "") {
      writer.uint32(10).string(message.condition);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BranchCfg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranchCfg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.condition = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BranchCfg {
    return { condition: isSet(object.condition) ? globalThis.String(object.condition) : "" };
  },

  toJSON(message: BranchCfg): unknown {
    const obj: any = {};
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BranchCfg>, I>>(base?: I): BranchCfg {
    return BranchCfg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BranchCfg>, I>>(object: I): BranchCfg {
    const message = createBaseBranchCfg();
    message.condition = object.condition ?? "";
    return message;
  },
};

function createBaseLogCfg(): LogCfg {
  return { name: "" };
}

export const LogCfg = {
  encode(message: LogCfg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LogCfg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogCfg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogCfg {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: LogCfg): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogCfg>, I>>(base?: I): LogCfg {
    return LogCfg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogCfg>, I>>(object: I): LogCfg {
    const message = createBaseLogCfg();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseOutputCfg(): OutputCfg {
  return { name: "" };
}

export const OutputCfg = {
  encode(message: OutputCfg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OutputCfg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputCfg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputCfg {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: OutputCfg): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputCfg>, I>>(base?: I): OutputCfg {
    return OutputCfg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputCfg>, I>>(object: I): OutputCfg {
    const message = createBaseOutputCfg();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseExecuteRequest(): ExecuteRequest {
  return { flow: undefined };
}

export const ExecuteRequest = {
  encode(message: ExecuteRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.flow !== undefined) {
      Flow.encode(message.flow, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.flow = Flow.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteRequest {
    return { flow: isSet(object.flow) ? Flow.fromJSON(object.flow) : undefined };
  },

  toJSON(message: ExecuteRequest): unknown {
    const obj: any = {};
    if (message.flow !== undefined) {
      obj.flow = Flow.toJSON(message.flow);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteRequest>, I>>(base?: I): ExecuteRequest {
    return ExecuteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteRequest>, I>>(object: I): ExecuteRequest {
    const message = createBaseExecuteRequest();
    message.flow = (object.flow !== undefined && object.flow !== null) ? Flow.fromPartial(object.flow) : undefined;
    return message;
  },
};

function createBasePortValue(): PortValue {
  return { port: "", value: new Uint8Array(0), type: "" };
}

export const PortValue = {
  encode(message: PortValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.port !== "") {
      writer.uint32(10).string(message.port);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PortValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.port = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortValue {
    return {
      port: isSet(object.port) ? globalThis.String(object.port) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: PortValue): unknown {
    const obj: any = {};
    if (message.port !== "") {
      obj.port = message.port;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortValue>, I>>(base?: I): PortValue {
    return PortValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortValue>, I>>(object: I): PortValue {
    const message = createBasePortValue();
    message.port = object.port ?? "";
    message.value = object.value ?? new Uint8Array(0);
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseNodeEvent(): NodeEvent {
  return { nodeId: "", event: "", value: undefined };
}

export const NodeEvent = {
  encode(message: NodeEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.event !== "") {
      writer.uint32(18).string(message.event);
    }
    if (message.value !== undefined) {
      PortValue.encode(message.value, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.event = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = PortValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeEvent {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      event: isSet(object.event) ? globalThis.String(object.event) : "",
      value: isSet(object.value) ? PortValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: NodeEvent): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.event !== "") {
      obj.event = message.event;
    }
    if (message.value !== undefined) {
      obj.value = PortValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeEvent>, I>>(base?: I): NodeEvent {
    return NodeEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeEvent>, I>>(object: I): NodeEvent {
    const message = createBaseNodeEvent();
    message.nodeId = object.nodeId ?? "";
    message.event = object.event ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? PortValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseExecuteResponse(): ExecuteResponse {
  return { events: [] };
}

export const ExecuteResponse = {
  encode(message: ExecuteResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.events) {
      NodeEvent.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.events.push(NodeEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteResponse {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => NodeEvent.fromJSON(e)) : [],
    };
  },

  toJSON(message: ExecuteResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => NodeEvent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteResponse>, I>>(base?: I): ExecuteResponse {
    return ExecuteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteResponse>, I>>(object: I): ExecuteResponse {
    const message = createBaseExecuteResponse();
    message.events = object.events?.map((e) => NodeEvent.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: flow.proto
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Empty } from "./google/protobuf/empty.js";
export const protobufPackage = "voide.flow";
function createBaseText() {
    return { value: "" };
}
export const Text = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseText();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Text.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseText();
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseJson() {
    return { value: new Uint8Array(0) };
}
export const Json = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.value.length !== 0) {
            writer.uint32(10).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJson();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0) };
    },
    toJSON(message) {
        const obj = {};
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        return obj;
    },
    create(base) {
        return Json.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseJson();
        message.value = object.value ?? new Uint8Array(0);
        return message;
    },
};
function createBaseEmbedding() {
    return { values: [] };
}
export const Embedding = {
    encode(message, writer = _m0.Writer.create()) {
        writer.uint32(10).fork();
        for (const v of message.values) {
            writer.float(v);
        }
        writer.ldelim();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEmbedding();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag === 13) {
                        message.values.push(reader.float());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.values.push(reader.float());
                        }
                        continue;
                    }
                    break;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            values: globalThis.Array.isArray(object?.values) ? object.values.map((e) => globalThis.Number(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.values?.length) {
            obj.values = message.values;
        }
        return obj;
    },
    create(base) {
        return Embedding.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEmbedding();
        message.values = object.values?.map((e) => e) || [];
        return message;
    },
};
function createBasePayload() {
    return { text: undefined, json: undefined, embedding: undefined, meta: {}, traceId: "", schemaVersion: 0 };
}
export const Payload = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.text !== undefined) {
            Text.encode(message.text, writer.uint32(10).fork()).ldelim();
        }
        if (message.json !== undefined) {
            Json.encode(message.json, writer.uint32(18).fork()).ldelim();
        }
        if (message.embedding !== undefined) {
            Embedding.encode(message.embedding, writer.uint32(26).fork()).ldelim();
        }
        Object.entries(message.meta).forEach(([key, value]) => {
            Payload_MetaEntry.encode({ key: key, value }, writer.uint32(82).fork()).ldelim();
        });
        if (message.traceId !== "") {
            writer.uint32(90).string(message.traceId);
        }
        if (message.schemaVersion !== 0) {
            writer.uint32(96).uint32(message.schemaVersion);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePayload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.text = Text.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.json = Json.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.embedding = Embedding.decode(reader, reader.uint32());
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    const entry10 = Payload_MetaEntry.decode(reader, reader.uint32());
                    if (entry10.value !== undefined) {
                        message.meta[entry10.key] = entry10.value;
                    }
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.traceId = reader.string();
                    continue;
                case 12:
                    if (tag !== 96) {
                        break;
                    }
                    message.schemaVersion = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            text: isSet(object.text) ? Text.fromJSON(object.text) : undefined,
            json: isSet(object.json) ? Json.fromJSON(object.json) : undefined,
            embedding: isSet(object.embedding) ? Embedding.fromJSON(object.embedding) : undefined,
            meta: isObject(object.meta)
                ? Object.entries(object.meta).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
            schemaVersion: isSet(object.schemaVersion) ? globalThis.Number(object.schemaVersion) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.text !== undefined) {
            obj.text = Text.toJSON(message.text);
        }
        if (message.json !== undefined) {
            obj.json = Json.toJSON(message.json);
        }
        if (message.embedding !== undefined) {
            obj.embedding = Embedding.toJSON(message.embedding);
        }
        if (message.meta) {
            const entries = Object.entries(message.meta);
            if (entries.length > 0) {
                obj.meta = {};
                entries.forEach(([k, v]) => {
                    obj.meta[k] = v;
                });
            }
        }
        if (message.traceId !== "") {
            obj.traceId = message.traceId;
        }
        if (message.schemaVersion !== 0) {
            obj.schemaVersion = Math.round(message.schemaVersion);
        }
        return obj;
    },
    create(base) {
        return Payload.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePayload();
        message.text = (object.text !== undefined && object.text !== null) ? Text.fromPartial(object.text) : undefined;
        message.json = (object.json !== undefined && object.json !== null) ? Json.fromPartial(object.json) : undefined;
        message.embedding = (object.embedding !== undefined && object.embedding !== null)
            ? Embedding.fromPartial(object.embedding)
            : undefined;
        message.meta = Object.entries(object.meta ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        message.traceId = object.traceId ?? "";
        message.schemaVersion = object.schemaVersion ?? 0;
        return message;
    },
};
function createBasePayload_MetaEntry() {
    return { key: "", value: "" };
}
export const Payload_MetaEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePayload_MetaEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Payload_MetaEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePayload_MetaEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBasePort() {
    return { nodeId: "", port: "" };
}
export const Port = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.nodeId !== "") {
            writer.uint32(10).string(message.nodeId);
        }
        if (message.port !== "") {
            writer.uint32(18).string(message.port);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePort();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.port = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
            port: isSet(object.port) ? globalThis.String(object.port) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeId !== "") {
            obj.nodeId = message.nodeId;
        }
        if (message.port !== "") {
            obj.port = message.port;
        }
        return obj;
    },
    create(base) {
        return Port.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePort();
        message.nodeId = object.nodeId ?? "";
        message.port = object.port ?? "";
        return message;
    },
};
function createBaseEdge() {
    return { from: undefined, to: undefined };
}
export const Edge = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.from !== undefined) {
            Port.encode(message.from, writer.uint32(10).fork()).ldelim();
        }
        if (message.to !== undefined) {
            Port.encode(message.to, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEdge();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.from = Port.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.to = Port.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            from: isSet(object.from) ? Port.fromJSON(object.from) : undefined,
            to: isSet(object.to) ? Port.fromJSON(object.to) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.from !== undefined) {
            obj.from = Port.toJSON(message.from);
        }
        if (message.to !== undefined) {
            obj.to = Port.toJSON(message.to);
        }
        return obj;
    },
    create(base) {
        return Edge.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEdge();
        message.from = (object.from !== undefined && object.from !== null) ? Port.fromPartial(object.from) : undefined;
        message.to = (object.to !== undefined && object.to !== null) ? Port.fromPartial(object.to) : undefined;
        return message;
    },
};
function createBaseNodeParam() {
    return { key: "", value: "" };
}
export const NodeParam = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNodeParam();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return NodeParam.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseNodeParam();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseNode() {
    return { id: "", type: "", params: [], inPorts: [], outPorts: [] };
}
export const Node = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.type !== "") {
            writer.uint32(18).string(message.type);
        }
        for (const v of message.params) {
            NodeParam.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.inPorts) {
            writer.uint32(34).string(v);
        }
        for (const v of message.outPorts) {
            writer.uint32(42).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.params.push(NodeParam.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.inPorts.push(reader.string());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.outPorts.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            params: globalThis.Array.isArray(object?.params) ? object.params.map((e) => NodeParam.fromJSON(e)) : [],
            inPorts: globalThis.Array.isArray(object?.inPorts) ? object.inPorts.map((e) => globalThis.String(e)) : [],
            outPorts: globalThis.Array.isArray(object?.outPorts) ? object.outPorts.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.params?.length) {
            obj.params = message.params.map((e) => NodeParam.toJSON(e));
        }
        if (message.inPorts?.length) {
            obj.inPorts = message.inPorts;
        }
        if (message.outPorts?.length) {
            obj.outPorts = message.outPorts;
        }
        return obj;
    },
    create(base) {
        return Node.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseNode();
        message.id = object.id ?? "";
        message.type = object.type ?? "";
        message.params = object.params?.map((e) => NodeParam.fromPartial(e)) || [];
        message.inPorts = object.inPorts?.map((e) => e) || [];
        message.outPorts = object.outPorts?.map((e) => e) || [];
        return message;
    },
};
function createBaseFlowDef() {
    return { id: "", nodes: [], edges: [], version: 0 };
}
export const FlowDef = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        for (const v of message.nodes) {
            Node.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.edges) {
            Edge.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.version !== 0) {
            writer.uint32(32).uint32(message.version);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlowDef();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.nodes.push(Node.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.edges.push(Edge.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.version = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e) => Node.fromJSON(e)) : [],
            edges: globalThis.Array.isArray(object?.edges) ? object.edges.map((e) => Edge.fromJSON(e)) : [],
            version: isSet(object.version) ? globalThis.Number(object.version) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.nodes?.length) {
            obj.nodes = message.nodes.map((e) => Node.toJSON(e));
        }
        if (message.edges?.length) {
            obj.edges = message.edges.map((e) => Edge.toJSON(e));
        }
        if (message.version !== 0) {
            obj.version = Math.round(message.version);
        }
        return obj;
    },
    create(base) {
        return FlowDef.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlowDef();
        message.id = object.id ?? "";
        message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
        message.edges = object.edges?.map((e) => Edge.fromPartial(e)) || [];
        message.version = object.version ?? 0;
        return message;
    },
};
export const EngineDefinition = {
    name: "Engine",
    fullName: "voide.flow.Engine",
    methods: {
        runFlow: {
            name: "RunFlow",
            requestType: FlowDef,
            requestStream: false,
            responseType: Payload,
            responseStream: true,
            options: {},
        },
        push: {
            name: "Push",
            requestType: Payload,
            requestStream: false,
            responseType: Payload,
            responseStream: false,
            options: {},
        },
    },
};
export const LLMDefinition = {
    name: "LLM",
    fullName: "voide.flow.LLM",
    methods: {
        complete: {
            name: "Complete",
            requestType: Payload,
            requestStream: false,
            responseType: Payload,
            responseStream: false,
            options: {},
        },
    },
};
export const MemoryDefinition = {
    name: "Memory",
    fullName: "voide.flow.Memory",
    methods: {
        /**
         * Two inputs one output design
         * write: persist only, no emit
         */
        write: {
            name: "Write",
            requestType: Payload,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        /** stream: retrieve and enrich, emit on out */
        retrieve: {
            name: "Retrieve",
            requestType: Payload,
            requestStream: false,
            responseType: Payload,
            responseStream: false,
            options: {},
        },
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}

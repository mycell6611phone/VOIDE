// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: flow.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Empty } from "./google/protobuf/empty.js";

export const protobufPackage = "voide.flow";

export interface Text {
  value: string;
}

export interface Json {
  value: Uint8Array;
}

export interface Embedding {
  values: number[];
}

export interface Payload {
  text?: Text | undefined;
  json?: Json | undefined;
  embedding?: Embedding | undefined;
  meta: { [key: string]: string };
  traceId: string;
  schemaVersion: number;
}

export interface Payload_MetaEntry {
  key: string;
  value: string;
}

export interface Port {
  nodeId: string;
  port: string;
}

export interface Edge {
  from: Port | undefined;
  to: Port | undefined;
}

export interface NodeParam {
  key: string;
  value: string;
}

export interface Node {
  id: string;
  /** "ui" | "prompt" | "memory" | "llm" */
  type: string;
  params: NodeParam[];
  inPorts: string[];
  outPorts: string[];
}

export interface FlowDef {
  id: string;
  nodes: Node[];
  edges: Edge[];
  version: number;
}

function createBaseText(): Text {
  return { value: "" };
}

export const Text = {
  encode(message: Text, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Text {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Text {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: Text): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Text>, I>>(base?: I): Text {
    return Text.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Text>, I>>(object: I): Text {
    const message = createBaseText();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseJson(): Json {
  return { value: new Uint8Array(0) };
}

export const Json = {
  encode(message: Json, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Json {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJson();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Json {
    return { value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0) };
  },

  toJSON(message: Json): unknown {
    const obj: any = {};
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Json>, I>>(base?: I): Json {
    return Json.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Json>, I>>(object: I): Json {
    const message = createBaseJson();
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseEmbedding(): Embedding {
  return { values: [] };
}

export const Embedding = {
  encode(message: Embedding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.float(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Embedding {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 13) {
            message.values.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Embedding {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: Embedding): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Embedding>, I>>(base?: I): Embedding {
    return Embedding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Embedding>, I>>(object: I): Embedding {
    const message = createBaseEmbedding();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBasePayload(): Payload {
  return { text: undefined, json: undefined, embedding: undefined, meta: {}, traceId: "", schemaVersion: 0 };
}

export const Payload = {
  encode(message: Payload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== undefined) {
      Text.encode(message.text, writer.uint32(10).fork()).ldelim();
    }
    if (message.json !== undefined) {
      Json.encode(message.json, writer.uint32(18).fork()).ldelim();
    }
    if (message.embedding !== undefined) {
      Embedding.encode(message.embedding, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.meta).forEach(([key, value]) => {
      Payload_MetaEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).ldelim();
    });
    if (message.traceId !== "") {
      writer.uint32(90).string(message.traceId);
    }
    if (message.schemaVersion !== 0) {
      writer.uint32(96).uint32(message.schemaVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Payload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = Text.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.json = Json.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.embedding = Embedding.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = Payload_MetaEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.meta[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.traceId = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.schemaVersion = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Payload {
    return {
      text: isSet(object.text) ? Text.fromJSON(object.text) : undefined,
      json: isSet(object.json) ? Json.fromJSON(object.json) : undefined,
      embedding: isSet(object.embedding) ? Embedding.fromJSON(object.embedding) : undefined,
      meta: isObject(object.meta)
        ? Object.entries(object.meta).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      schemaVersion: isSet(object.schemaVersion) ? globalThis.Number(object.schemaVersion) : 0,
    };
  },

  toJSON(message: Payload): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = Text.toJSON(message.text);
    }
    if (message.json !== undefined) {
      obj.json = Json.toJSON(message.json);
    }
    if (message.embedding !== undefined) {
      obj.embedding = Embedding.toJSON(message.embedding);
    }
    if (message.meta) {
      const entries = Object.entries(message.meta);
      if (entries.length > 0) {
        obj.meta = {};
        entries.forEach(([k, v]) => {
          obj.meta[k] = v;
        });
      }
    }
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.schemaVersion !== 0) {
      obj.schemaVersion = Math.round(message.schemaVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Payload>, I>>(base?: I): Payload {
    return Payload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Payload>, I>>(object: I): Payload {
    const message = createBasePayload();
    message.text = (object.text !== undefined && object.text !== null) ? Text.fromPartial(object.text) : undefined;
    message.json = (object.json !== undefined && object.json !== null) ? Json.fromPartial(object.json) : undefined;
    message.embedding = (object.embedding !== undefined && object.embedding !== null)
      ? Embedding.fromPartial(object.embedding)
      : undefined;
    message.meta = Object.entries(object.meta ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.traceId = object.traceId ?? "";
    message.schemaVersion = object.schemaVersion ?? 0;
    return message;
  },
};

function createBasePayload_MetaEntry(): Payload_MetaEntry {
  return { key: "", value: "" };
}

export const Payload_MetaEntry = {
  encode(message: Payload_MetaEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Payload_MetaEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayload_MetaEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Payload_MetaEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Payload_MetaEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Payload_MetaEntry>, I>>(base?: I): Payload_MetaEntry {
    return Payload_MetaEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Payload_MetaEntry>, I>>(object: I): Payload_MetaEntry {
    const message = createBasePayload_MetaEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePort(): Port {
  return { nodeId: "", port: "" };
}

export const Port = {
  encode(message: Port, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.port !== "") {
      writer.uint32(18).string(message.port);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Port {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.port = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Port {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      port: isSet(object.port) ? globalThis.String(object.port) : "",
    };
  },

  toJSON(message: Port): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.port !== "") {
      obj.port = message.port;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Port>, I>>(base?: I): Port {
    return Port.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Port>, I>>(object: I): Port {
    const message = createBasePort();
    message.nodeId = object.nodeId ?? "";
    message.port = object.port ?? "";
    return message;
  },
};

function createBaseEdge(): Edge {
  return { from: undefined, to: undefined };
}

export const Edge = {
  encode(message: Edge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Port.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Port.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Edge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Port.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Port.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Edge {
    return {
      from: isSet(object.from) ? Port.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Port.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: Edge): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Port.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Port.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Edge>, I>>(base?: I): Edge {
    return Edge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Edge>, I>>(object: I): Edge {
    const message = createBaseEdge();
    message.from = (object.from !== undefined && object.from !== null) ? Port.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Port.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseNodeParam(): NodeParam {
  return { key: "", value: "" };
}

export const NodeParam = {
  encode(message: NodeParam, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeParam {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeParam {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodeParam): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeParam>, I>>(base?: I): NodeParam {
    return NodeParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeParam>, I>>(object: I): NodeParam {
    const message = createBaseNodeParam();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNode(): Node {
  return { id: "", type: "", params: [], inPorts: [], outPorts: [] };
}

export const Node = {
  encode(message: Node, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    for (const v of message.params) {
      NodeParam.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.inPorts) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.outPorts) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Node {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.params.push(NodeParam.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.inPorts.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.outPorts.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      params: globalThis.Array.isArray(object?.params) ? object.params.map((e: any) => NodeParam.fromJSON(e)) : [],
      inPorts: globalThis.Array.isArray(object?.inPorts) ? object.inPorts.map((e: any) => globalThis.String(e)) : [],
      outPorts: globalThis.Array.isArray(object?.outPorts) ? object.outPorts.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.params?.length) {
      obj.params = message.params.map((e) => NodeParam.toJSON(e));
    }
    if (message.inPorts?.length) {
      obj.inPorts = message.inPorts;
    }
    if (message.outPorts?.length) {
      obj.outPorts = message.outPorts;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    message.id = object.id ?? "";
    message.type = object.type ?? "";
    message.params = object.params?.map((e) => NodeParam.fromPartial(e)) || [];
    message.inPorts = object.inPorts?.map((e) => e) || [];
    message.outPorts = object.outPorts?.map((e) => e) || [];
    return message;
  },
};

function createBaseFlowDef(): FlowDef {
  return { id: "", nodes: [], edges: [], version: 0 };
}

export const FlowDef = {
  encode(message: FlowDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.edges) {
      Edge.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.version !== 0) {
      writer.uint32(32).uint32(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FlowDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlowDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.edges.push(Edge.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.version = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlowDef {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      edges: globalThis.Array.isArray(object?.edges) ? object.edges.map((e: any) => Edge.fromJSON(e)) : [],
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: FlowDef): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    if (message.edges?.length) {
      obj.edges = message.edges.map((e) => Edge.toJSON(e));
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlowDef>, I>>(base?: I): FlowDef {
    return FlowDef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlowDef>, I>>(object: I): FlowDef {
    const message = createBaseFlowDef();
    message.id = object.id ?? "";
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    message.edges = object.edges?.map((e) => Edge.fromPartial(e)) || [];
    message.version = object.version ?? 0;
    return message;
  },
};

export type EngineDefinition = typeof EngineDefinition;
export const EngineDefinition = {
  name: "Engine",
  fullName: "voide.flow.Engine",
  methods: {
    runFlow: {
      name: "RunFlow",
      requestType: FlowDef,
      requestStream: false,
      responseType: Payload,
      responseStream: true,
      options: {},
    },
    push: {
      name: "Push",
      requestType: Payload,
      requestStream: false,
      responseType: Payload,
      responseStream: false,
      options: {},
    },
  },
} as const;

export type LLMDefinition = typeof LLMDefinition;
export const LLMDefinition = {
  name: "LLM",
  fullName: "voide.flow.LLM",
  methods: {
    complete: {
      name: "Complete",
      requestType: Payload,
      requestStream: false,
      responseType: Payload,
      responseStream: false,
      options: {},
    },
  },
} as const;

export type MemoryDefinition = typeof MemoryDefinition;
export const MemoryDefinition = {
  name: "Memory",
  fullName: "voide.flow.Memory",
  methods: {
    /**
     * Two inputs one output design
     * write: persist only, no emit
     */
    write: {
      name: "Write",
      requestType: Payload,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** stream: retrieve and enrich, emit on out */
    retrieve: {
      name: "Retrieve",
      requestType: Payload,
      requestStream: false,
      responseType: Payload,
      responseStream: false,
      options: {},
    },
  },
} as const;

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
